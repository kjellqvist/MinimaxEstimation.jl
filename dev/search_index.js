var documenterSearchIndex = {"docs":
[{"location":"lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [MinimaxEstimation]","category":"page"},{"location":"lib/#MinimaxEstimation.MinimaxEstimation","page":"Library","title":"MinimaxEstimation.MinimaxEstimation","text":"Main module for MinimaxEstimation.jl\n\n\n\n\n\n","category":"module"},{"location":"lib/#MinimaxEstimation.BayesianMMAE-Union{Tuple{AbstractArray{KalmanFilter{T}, 1}}, Tuple{T}} where T<:AbstractFloat","page":"Library","title":"MinimaxEstimation.BayesianMMAE","text":"mmae = BayesianMMAE(filterbank)\n\nConstruct a standard Multiple Model Adaptive Estimator object.\n\nCreate an estimator for the case where the dynamics belong to  the finite set of linear systems equations\n\nbeginaligned\nx_t+1  = F_ix_t + B_iu_t + w_t + textoffset_i\ny_t      = H_ix_t + v_t\nendaligned\n\nfilterbank is an array of KalmanFilter objects associated with the dynamics and disturbance characteristics of each i.\n\n\n\n\n\n","category":"method"},{"location":"lib/#MinimaxEstimation.KalmanFilter-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Library","title":"MinimaxEstimation.KalmanFilter","text":"kf = KalmanFilter(x, F, H, B, P, Q, R, offset)\n\nCreate a KalmanFilter object.\n\nfor the dynamical system \n\nbeginaligned\nx_t+1  = Fx_t + Bu_t + w_t + textoffset\ny_t      = Hx_t + v_t\nendaligned\n\nwhere x_tin mathbbR^n are the states, uin mathbbR^p are known inputs  y_tin mathbbR^m are measured outputs and   w_tin mathbbR^n v_t in mathbbR^m are unknown, uncorrelated disturbances,  with positive definite covariance matrices Q in mathbbR^ntimes n and  R in mathbbR^mtimes m respectively. The offset is an n-dimensional constant.\n\n\n\n\n\n","category":"method"},{"location":"lib/#MinimaxEstimation.MinimaxMMAE-Union{Tuple{T}, Tuple{AbstractArray{KalmanFilter{T}, 1}, Function}} where T<:AbstractFloat","page":"Library","title":"MinimaxEstimation.MinimaxMMAE","text":"mini = MinimaxMMAE(filterbank, γ, optimizer)\n\nConstruct a Minimax Multiple Model Adaptive Estimator object.\n\nCreate an estimator for the case where the dynamics belong to  the finite set of linear systems equations\n\nbeginaligned\nx_t+1  = F_ix_t + B_iu_t + w_t + textoffset_i\ny_t      = H_ix_t + v_t\nendaligned\n\nand the associated objective\n\nmin_hat y_Nmax_x_0 mathbfw^N mathbfv^N iBigg hat y_N - H_ix_N^2 - gamma^2left(x_0 - hat x_0^2_P_0^-1 + sum_t=0^N-1 w_t^2_Q^-1 + v_t^2_R^-1right)Bigg\n\nFilterbank is an array of KalmanFilter object associated with each i.\n\n\n\n\n\n","category":"method"},{"location":"lib/#MinimaxEstimation.predict-Tuple{MinimaxEstimation.AbstractFilter}","page":"Library","title":"MinimaxEstimation.predict","text":"predict(filter)\n\nPredict the states at the next time instance.\n\nMethods\n\nxhat = predict(filter::KalmanFilter)\n\nGet the kalman filter prediction of the state at the next time-step, hat x_t+1.\n\nyhat, val = predict(minimaxfilter)\n\nPredict the output of the next time-step as the minimizing argument of  the quadratically constrainde convex program\n\nJ_N^star(y)= min_hat y max_i hat y - H_ibreve x_Ni^2_(I-gamma^-2H_iP_NiH_i^top)^-1 - gamma^2 c_Ni\n\nyhat = predict(bayesianfilter)\n\nPredict the output at the next time-step as the expected value Ehat y_t+1 = sum_i=1^K breve y_i p(iy_t), where breve y_i are the corresponding KalmanFilter estimates.\n\n\n\n\n\n","category":"method"},{"location":"lib/#MinimaxEstimation.update!-Tuple{MinimaxEstimation.AbstractFilter, Any, Any}","page":"Library","title":"MinimaxEstimation.update!","text":"update!(filter, y, u)\n\nUpdate the internal states of the filter in accordance with the output y and input u.\n\nMethods\n\nupdate!(filter::KalmanFilter, y, u)\n\nUpdate the internal states of the KalmanFilter in according to measured output y and controlled input u.\n\nThe internal states are updated as follows\n\nbeginaligned\nP_t+1  = Q + FP_tF^top quad - FP_tH^top(R + HP_tH^top)^-1H P_tF^top \nbrevex_t+1    = F brevex_t + K_t(y_t - Hbrevex_t)\nK_t      = FP_tH^top(R + H P_t H^top)^-1 \nc_t+1  = H_ibreve x_t -y_t^2_(R + HP_tH^top)^-1 + c_t \np(iy_t)  = frac1(2pi)^n2sqrtR + HP_tH^tope^-12 (Hhat x_t - y_t)^top (R + HP_tH^top)^-1(Hx_t-y_t)p(iy_t-1)\nendaligned\n\nThe cummulative costs c_t are states used by Minimax Adaptive Estimators, and p(iy_t) are states used by the standard adaptive estimator.\n\nupdate!(filter::MinimaxFilter, y, u)\n\nUpdate each filter in the internal filterbank of the minimaxfilter object.\n\nupdate!(filter::BayesianFilter, y, u)\n\nUpdate each filter in the internal filterbank of the standard multiple model adaptive filter and normalize the probability of a given state being active conditioned on past measurements, p(i y_t).\n\n\n\n\n\n","category":"method"},{"location":"#MinimaxEstimation","page":"Home","title":"MinimaxEstimation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for reproducing and experimenting with the results from the article Minimax Adaptive Estimation for Finite Sets of Linear Systems. https://arxiv.org/abs/2103.02479","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg;\nPkg.add(url=\"https://github.com/kjellqvist/MinimaxEstimation.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"and activate the environment by running","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.activate(\"MinimaxEstimation\")","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"example/#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The example in the article is restated below, with a self-contained code block to reproduce the results.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"beginaligned\nx_t+1  = pm x_t + w_t \ny_t      = x_t + v_t \nx_0      = 0\nendaligned","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where iin-11 u_t = sin(t5), v_t and w_t are unit intensity, uncorrelated, Gaussian white noise. Further, Q = I R = I P_0 = I. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using Ipopt\nusing LinearAlgebra\nusing MinimaxEstimation\nusing Plots\nusing Random\nusing LaTeXStrings\n\nRandom.seed!(10)\nn_steps = 20\nF1 = 1\nF2 = -1\nF = F1  # The \"true\" generating system\nH = 1\nx0 = 0\n(Q, R, P0) = (1, 1, 1) # Norm\nkf1 = KalmanFilter(x0, F1, H, P0, Q, R)\nkf2 = KalmanFilter(x0, F2, H, P0, Q, R)\n#mini = MinimaxMMAE([kf1, kf2],Mosek.Optimizer)\nmini = MinimaxMMAE([kf1, kf2],() -> Ipopt.Optimizer())\nbayes = BayesianMMAE([kf1, kf2])\nv = randn((1, n_steps)) # Measurement noise\nw = randn((1, n_steps)) # Process disturbance\ny = zeros(n_steps+1)    # Noisy output\nz = zeros(n_steps+1)    # Hx -> Noise-free output\nyhat1 = zeros(n_steps+1)   # \nyhat2 = zeros(n_steps+1)\nyhatmini = zeros(n_steps+1,1)\nyhatbayes = zeros(n_steps+1,1)\nγmins = zeros(n_steps+1)\nγminimaxs = zeros(n_steps+1)\nγbayes = zeros(n_steps+1)\nvals = zeros(n_steps+1)\n\nfunction bisectgamma(filter::BayesianMMAE; γmax::Real = 100)\n    yhat = predict(filter)\n    γmin = sqrt(maximum([maximum(eigvals(kf.H*kf.P*kf.H')) for kf in filter.filterbank]))\n    γmax < γmin ? error(DomainError((γmax, γmin), \"γmax smaller than γmin\")) : nothing\n    γ = (γmin + γmax)/2 \n    for k = 1:20\n        J(filter, yhat, γ) < 0 ? γmax = γ : γmin = γ\n        γ = (γmin + γmax)/2\n    end\n    return γ\nend\n\nfunction J(filter::BayesianMMAE, yhat, γ)\n    cost = -Inf\n    for f in filter.filterbank\n        W = (I - γ^(-2)*f.H*f.P*f.H')\n        cost = max((yhat - f.H*f.x)'*pinv(W)*(yhat - f.H*f.x) - γ^2*f.c[], cost)\n    end\n    return cost\nend\n\nx = x0\nfor k=1:n_steps\n        # Updates all Kalman filters and calculates the conditional probabilities\n    update!(bayes, y[k])   \n    yhat1[k+1] = predict(kf1)[1]\n    yhat2[k+1] = predict(kf2)[1]\n    γmins[k+1] = sqrt(maximum([maximum(eigvals(kf1.P)) maximum(eigvals(kf2.P))]))\n    yhatmini[k+1,:], vals[k+1], γminimaxs[k+1] = predict(mini, γmax = 3)\n    yhatbayes[k+1,:] = predict(bayes)\n    γbayes[k+1] = bisectgamma(bayes, γmax = 3)\n    global x = F*x + w[1,k]\n    y[k+1] = (H*x)[1] + v[k]\n    z[k+1] = (H*x)[1]\nend\n\nplot(\n    ([γmins γminimaxs γbayes])[2:end,:],\n    labels = [L\"\\max\\sqrt{P_{N,i}}\" \"Minimax\" \"Bayes\"],\n    linewidth = 3,\n    xlabel = \"N\",\n    ylabel = L\"\\gamma_N^\\star\",\n    markershape = :o)\nsavefig(\"experiment.svg\"); nothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using Ipopt\nusing LinearAlgebra\nusing MinimaxEstimation\nusing Plots\nusing Random\nusing LaTeXStrings\n\nRandom.seed!(10)\nn_steps = 20\nF1 = 1\nF2 = -1\nF = F1  # The \"true\" generating system\nH = 1\nx0 = 0\n(Q, R, P0) = (1, 1, 1) # Norm\nkf1 = KalmanFilter(x0, F1, H, P0, Q, R)\nkf2 = KalmanFilter(x0, F2, H, P0, Q, R)\nmini = MinimaxMMAE([kf1, kf2],() -> Ipopt.Optimizer())\nbayes = BayesianMMAE([kf1, kf2])\nv = randn((1, n_steps)) # Measurement noise\nw = randn((1, n_steps)) # Process disturbance\ny = zeros(n_steps+1)    # Noisy output\nz = zeros(n_steps+1)    # Hx -> Noise-free output\nyhat1 = zeros(n_steps+1)   # \nyhat2 = zeros(n_steps+1)\nyhatmini = zeros(n_steps+1,1)\nyhatbayes = zeros(n_steps+1,1)\nγmins = zeros(n_steps+1)\nγminimaxs = zeros(n_steps+1)\nγbayes = zeros(n_steps+1)\nvals = zeros(n_steps+1)\n\nfunction bisectgamma(filter::BayesianMMAE; γmax::Real = 100)\n    yhat = predict(filter)\n    γmin = sqrt(maximum([maximum(eigvals(kf.H*kf.P*kf.H')) for kf in filter.filterbank]))\n    γmax < γmin ? error(DomainError((γmax, γmin), \"γmax smaller than γmin\")) : nothing\n    γ = (γmin + γmax)/2 \n    for k = 1:20\n        J(filter, yhat, γ) < 0 ? γmax = γ : γmin = γ\n        γ = (γmin + γmax)/2\n    end\n    return γ\nend\n\nfunction J(filter::BayesianMMAE, yhat, γ)\n    cost = -Inf\n    for f in filter.filterbank\n        W = (I - γ^(-2)*f.H*f.P*f.H')\n        cost = max((yhat - f.H*f.x)'*pinv(W)*(yhat - f.H*f.x) - γ^2*f.c[], cost)\n    end\n    return cost\nend\n\nx = x0\nfor k=1:5\n    # Updates all Kalman filters and calculates the conditional probabilities\n    update!(bayes, y[k])   \n    yhat1[k+1] = predict(kf1)[1]\n    yhat2[k+1] = predict(kf2)[1]\n    global x = F*x + w[1,k]\n    y[k+1] = (H*x)[1] + v[k]\n    z[k+1] = (H*x)[1]\nend\n\nyhat1 = H*predict(kf1)\nyhat2 = H*predict(kf2)\nf1 = x-> (yhat1[1] - x)^2/(1-γ^(-2)*kf1.P[1,1]) - γ^2*kf1.c[]\nf2 = x-> (yhat2[1] - x)^2/(1-γ^(-2)*kf2.P[1,1]) - γ^2*kf2.c[]\n\nyhatmini, Jmini, γ = predict(mini, γmax = 3)\nyhatbayes = predict(bayes)\nJbayes = J(bayes, yhatbayes, γ)\nlower = -2\nupper = 0\nplt = plot(lower:0.01:upper, f1, linestyle = :dash, linewidth = 2, labels = L\"J^+_5\")\nplot!(plt, lower:0.01:upper, f2, linestyle = :dash, linewidth = 2, labels = L\"J^-_5\")\nplot!(plt, lower:0.01:upper, x -> max(f1(x), f2(x)), linecolor = :black, linewidth = 2, labels = L\"\\max\\{J^+_5, J^-_5\\}\")\nplot!(plt,yhatmini, [Jmini], marker = :o, markersize = 8, markercolor = :blue, labels = \"Minimax\")\nplot!(plt,yhatbayes, [Jbayes], marker = :x, markersize = 8, markercolor = :green, labels = \"Bayes\")\nxlabel!(L\"\\hat y_5\")\nylabel!(L\"J_5\")\nsavefig(\"experiment_2.svg\"); nothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: )","category":"page"}]
}
